--- 8 bit discrete BJT processor ---
--- jamiebrn 2026

Harvard architecture
8 bit word size
16 bit program address space (EEPROM)
16 bit working memory (SRAM):
 - 8 bit address width
 - 256 banks (switchable via bank register)
 - Bank 256 reserved for call stack

Registers:
 - 16 bit PC (jk counter with overwrite)
 - 8 bit general purpose/accessible A, B, C     (0x0 / ra, 0x1 / rb, 0x2 / rc)
 - 8 bit IR0, IR1, IR2
 - 8 bit SP                                     (0xA / rsp)
 - 8 bit BP                                     (0xB / rbp)
 - 8 bit BANK                                   (0xE / rbnk)
 - 8 bit ADDR                                   (0xF / radr)
 - 4 bit FLAGS

Variable instruction length (1-3 bytes)

CPU main data path goes only through the ALU.
Registers are not directly connected - register transfers are facilitated by ALU operations, e.g. iadd ra rb 0, which transfers rb to ra.

All memory addressing operations will operate in the current bank.

Access of rsp and rbp is intended for read-only purposes (e.g. lda from stack), but writing is permitted.

ALU:
 - Addition
 - Subtraction
 - Bitwise NAND
 - Passthrough (No Op - necessary for immediate mode due to the ALU being the only datapath between registers)

ISA:
    -- 1 byte instructions --
    stop                            (0x00)

    ret                             (0x01)                      // return from func - pop PC & BP from stack

    pcall                           (0x02)                      // call func ptr - push BP and PC to stack, BP set to SP, PC set to ADDR

    pop     rZ                      (0x2Z)                      // pop stack into reg Z
    
    lda     rZ                      (0xFZ)                      // load memory contents at ADDR into reg Z

    plda    rZ                      (0x3Z)                      // load ROM contents at ADDR into reg Z

    -- 2 byte instructions --
    add     rZ      rX      rY      (0x4Z XY)                   // add reg X and reg Y, store in reg Z

    addc    rZ      rX      rY      (0x5Z XY)                   // add considering carry flag

    sub     rZ      rX      rY      (0x7Z XY)                   // sub reg X and reg Y, store in reg Z

    subc    rZ      rX      rY      (0x8Z XY)                   // sub considering carry flag

    imm     rZ      XX              (0xAZ XX)                   // store immediate byte in reg Z

    nand    rZ      rX      rY      (0xBZ XY)                   // bitwise NAND reg X and reg Y, store in reg Z
    
    push    rX                      (0x10 X0)                   // push reg X onto stack

    sto     rX                      (0x11 X0)                   // store reg X at address in ADDR

    cmp     rX      rY              (0x12 XY)                   // update FLAGS with reg X and reg Y as operands

    strla   rX      rY              (0x60 XY)                   // store reg A at address X + Y

    ldrl    rZ      rX      rY      (0x9Z XY)                   // load memory contents at address X + Y into reg Z

    -- 3 byte instructions --
    iadd    rZ      rX      YY      (0xCZ X0 YY)                // immediate add to reg X, store in Z

    isub    rZ      rX      YY      (0xDZ X0 YY)                // immediate sub from reg X, store in Z

    jmp     XXXX                    (0xE0 XX XX)                // (conditional) jumps
    jmpz    XXXX                    (0xE1 XX XX)
    jmpn    XXXX                    (0xE2 XX XX)
    jmpc    XXXX                    (0xE4 XX XX)
    jmpo    XXXX                    (0xE8 XX XX)

    call    XXXX                    (0xEA XX XX)                // call func/address - push BP and PC to stack, BP set to SP, PC set to XXXX


ASM Pseudo-OPs:
    cpy     rZ      rX              (iadd   rZ      rX      0x00)       // copy value from reg X to reg Z
    
    setadr  XXYY                    (imm    rbnk    XX
                                     imm    radr    YY)                 // set 16 bit address pointed to by bank and address registers


Calling Convention:
 - Return in ra (with high in rb if 16 bit)
 - Pass parameters in ra, rb, rc, then push to stack (caller must pop)
 - All non-parameter registers (e.g. rb, rc for a 1 parameter function) must be retained on return
 - BANK and ADDR should be retained unless function behaviour explicitly mutates


 --- Extensions ---

Video:
 - 64x64 4 bit greyscale
 - Write only via virtual register (0x9 / rdis)
 - Protocol:
   - 0b00000001 - clear
   - 0b01XXXXXX - set cursor X
   - 0b10YYYYYY - set cursor Y
   - 0b1100XXXX - write colour XXXX